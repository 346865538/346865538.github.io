<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Welcome]]></title>
      <url>%2F8888%2F01%2F01%2FWelcome%2F</url>
      <content type="text"><![CDATA[欢迎来到我的博客，在这里我会分享一些我在前端路上的一些经验GitHub : https://github.com/346865538]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React 初识]]></title>
      <url>%2F2017%2F04%2F10%2FReact%2F</url>
      <content type="text"><![CDATA[初始化React1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;React&lt;/title&gt; &lt;!--引入react核心库--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;build/react.js&quot;&gt;&lt;/script&gt; &lt;!--引入react的dom操作--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;!--把jsx语法转换成浏览器识别的js语法--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--把通过react生成的dom放置在这里--&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;!--写jsx的地方需要设置为text/babel--&gt; &lt;script type=&quot;text/babel&quot;&gt; &lt;/script&gt;&lt;/html&gt; ReactDOM.render123456789101112131415161718192021222324252627// 把react的dom结构渲染到页面需要的命令为 ReactDom.render()// 包括三个参数// 1.需要渲染的DOM结构// 2.要插入到的节点// 3.渲染成功的回调 (一般都不写)ReactDOM.render( &lt;h1&gt;我是标题&lt;/h1&gt;, document.getElementById(&quot;container&quot;))// jsx 是一个语法 不是一门新的语言// 既包括JavaScript 和 XHTML 语言// XHTML 就用标签来进行表示// JavaScript 用&#123;&#125;表示var names = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;];ReactDOM.render( &lt;ul&gt; &#123; names.map(function(name,key)&#123; return &lt;li key=&#123;key&#125;&gt;&#123;name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;, document.getElementById(&quot;container&quot;)) 组件 component123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 在react中 将一些重用的DOM结构进行封装 就称为组件(component)// 一个组件就是一个组件类// 命名规则：// 首字母必须大写 使用驼峰命名法// 构建一个组件类使用 React.createClass()// 包含一个必须的方法是 render 它可以给我们返回一个或一组能够渲染的dom结构// 在react里如果输出多个同级标签 一定要加上一个父级var HelloMessage = React.createClass(&#123; render:function()&#123; return &lt;h1&gt;hello message&lt;/h1&gt;; &#125;&#125;)ReactDOM.render( &lt;HelloMessage/&gt;, document.getElementById(&apos;container&apos;))// 复合组件 可以把多个组件相互组合 组成一个符合组件var WebName = React.createClass(&#123; render:function()&#123; return &lt;h1&gt;我是WebShow&lt;/h1&gt; &#125;&#125;)var WebLink = React.createClass(&#123; render:function()&#123; return &lt;a href=&quot;http://www.lanou3g.com&quot;&gt;蓝鸥科技&lt;/a&gt; &#125;&#125;)var WebShow = React.createClass(&#123; render:function()&#123; return &lt;div&gt; &lt;WebName/&gt; &lt;WebLink/&gt; &lt;/div&gt; &#125;&#125;)ReactDOM.render( &lt;WebShow/&gt;, document.getElementById(&quot;container&quot;))//*react的css样式可以分为三类// 1.内联样式// 2.对象样式// 3.选择器样式// 1.使用内联样式给div添加背景颜色和边框// 2.使用对象样式给h1添加字体颜色和背景颜色// 3.使用选择器样式geip添加字体颜色和背景颜色 !使用classNamevar styles = &#123; color:&quot;blue&quot;, backgroundColor:&quot;green&quot;&#125;var StyleTest = React.createClass(&#123; render:function()&#123; return (&lt;div style=&#123;&#123;backgroundColor:&quot;red&quot;,borderWidth:&quot;1px&quot;,borderColor:&quot;green&quot;,borderStyle:&quot;solid&quot;&#125;&#125;&gt; &lt;h1 style=&#123;styles&#125;&gt;我是标题&lt;/h1&gt; &lt;p className=&quot;act&quot;&gt;我是段落&lt;/p&gt; &lt;/div&gt;) &#125;&#125;)ReactDOM.render( &lt;StyleTest/&gt;, document.getElementById(&quot;container&quot;)) 组件的属性 props12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//* props 代表的是一个组件的属性 实质上是从父组件传递一些值到子组件上// 一般情况下props最好不要更改// 使用时通过this.props, this代表父组件 props是一个数组 包含了父组件上所有的属性var WebName = React.createClass(&#123; render:function()&#123; return &lt;h1&gt;&#123;this.props.webname&#125;&lt;/h1&gt; &#125;&#125;)var WebLink = React.createClass(&#123; render:function()&#123; return &lt;a href=&#123;this.props.weblink&#125;&gt;&#123;this.props.weblink&#125;&lt;/a&gt; &#125;&#125;)var WebShow = React.createClass(&#123; render:function()&#123; return (&lt;div&gt; &lt;WebName webname=&#123;this.props.wname&#125;/&gt; &lt;WebLink weblink=&#123;this.props.wlink&#125;/&gt; &lt;/div&gt;) &#125;&#125;)ReactDOM.render( &lt;WebShow wname=&quot;百度&quot; wlink=&quot;http://www.baidu.com&quot;/&gt;, document.getElementById(&quot;container&quot;))// this.props里面的值与组件上的属性一一对应 一般不会更改 但是能够设置初始值var PropsTest = React.createClass(&#123; propTypes:&#123; // 设置props的数据类型 age:React.PropTypes.number.isequired &#125;, getDefaultProps:function()&#123; // 设置该组件属性的初始值 return &#123; name:&quot;lisi&quot;, age:18 &#125; &#125;, render:function()&#123; return &lt;h1&gt;hello &#123;this.props.name&#125;! 年龄是&#123;this.props.age&#125;&lt;/h1&gt; &#125;&#125;)var age = 18;ReactDOM.render( &lt;PropsTest/&gt;,// &lt;PropsTest name=&quot;zhangsan&quot;/&gt;, document.getElementById(&quot;container&quot;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular 进阶]]></title>
      <url>%2F2017%2F04%2F10%2FAngular%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[controller 控制器1234567891011121314151617181920212223242526272829303132&lt;body&gt; &lt;!--在一个页面里只能存在一个ng-app=&quot;&quot;,多了就只执行第一个,但是在一个页面里可以划分为不同的部分,(使用不同的控制器(controller)进行划分)--&gt; &lt;!--每个控制器都有一个域,这个域使用$scope表示--&gt; &lt;!--&lt;div ng-app=&quot;myapp&quot; ng-controller=&quot;mycontroller&quot; &gt; &lt;button ng-click=&quot;clickFn()&quot;&gt;点击&lt;/button&gt; &lt;input type=&quot;text&quot; ng-model=&quot;arr[2]&quot;/&gt; hello,&#123;&#123;arr[2]&#125;&#125; &lt;/div&gt; --&gt; &lt;div ng-app=&quot;myapp&quot;&gt; &lt;div ng-controller=&quot;mycon1&quot;&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;div ng-controller=&quot;mycon2&quot;&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 获取一下app 中括号表示引入的依赖 var app = angular.module(&quot;myapp&quot;,[]); // 设置控制器 app.controller(&quot;mycon1&quot;,function($scope)&#123; $scope.name = &quot;zhangsan&quot;; &#125;); app.controller(&quot;mycon2&quot;,function($scope)&#123; $scope.name = &quot;lisi&quot;; &#125;)&lt;/script&gt; directive 自定义属性12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;myController&quot;&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;ng-hello&gt;&lt;/ng-hello&gt; &lt;div ng-hello=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ng-hello&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 封装自定义属性 var app = angular.module(&quot;myApp&quot;,[]); app.controller(&quot;myController&quot;,function($scope)&#123; $scope.name=&quot;div&quot;; &#125;) //创建指令(对常用的dom结构和功能进行分装) app.directive(&quot;ngHello&quot;,function()&#123; return &#123; // restrict : &quot;A&quot;,//属性类型 // restrict : &quot;E&quot;,//标签类型 // restrict : &quot;C&quot;,//class类型 restrict: &quot;M&quot;, //作为注释使用 // restrict:默认为EA restrict : &quot;AEC&quot;,//全部类型 template : &quot;&lt;h1&gt;&lt;a href=&apos;###&apos;&gt;我是一个超文本链接&lt;/a&gt;&lt;/h1&gt;&quot; &#125; &#125;)&lt;/script&gt; Server请求文件内容12345678910var app = angular.module(&quot;myapp&quot;,[&quot;ngSanitize&quot;]);app.controller(&quot;mycon&quot;,function($scope,$http)&#123; $http.get(&quot;test.txt&quot;).then(function(res)&#123; // 成功的回调 $scope.content = res.data; &#125;,function(err)&#123; // 失败的回调 console.log(err); &#125;)&#125;) ngSanitize12345678910111213&lt;body ng-app=&quot;myapp&quot; ng-controller=&quot;mycon&quot;&gt; &lt;div ng-bind-html=&quot;content&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular-sanitize.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&quot;myapp&quot;,[&quot;ngSanitize&quot;]); app.controller(&quot;mycon&quot;,function($scope,$location)&#123; &lt;!--获取url--&gt; console.log($location.absUrl()); &#125;)&lt;/script&gt; 仿写百度搜索下拉栏123456789101112131415161718192021222324&lt;body ng-app=&quot;myapp&quot; ng-controller=&quot;mycon&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;name&quot; ng-change=&quot;change()&quot; /&gt; &lt;hr /&gt; &lt;table class=&quot;table table-striped&quot;&gt; &lt;tr ng-repeat=&quot;x in arr&quot;&gt; &lt;td&gt;&#123;&#123;x&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular-sanitize.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&quot;myapp&quot;,[]); app.controller(&quot;mycon&quot;,function($scope,$http)&#123; $scope.change = function()&#123; &lt;!--jsonp--&gt; $http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot;+$scope.name+&quot;&amp;cb=JSON_CALLBACK&quot;).then(function(res)&#123; console.log(res.data); console.log(res.data.s); $scope.arr = res.data.s; &#125;) &#125; &#125;)&lt;/script&gt; 定时器 $timeout $interval123456789101112var app = angular.module(&quot;myapp&quot;,[]);app.controller(&quot;mycon&quot;,function($scope,$timeout)&#123; $timeout(function()&#123; console.log(&quot;a你好啊&quot;); &#125;,2000)&#125;) app.controller(&quot;mycon&quot;,function($scope,$interval)&#123; $interval(function()&#123; console.log(&quot;你好啊&quot;); &#125;,100)&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular 初识]]></title>
      <url>%2F2017%2F04%2F10%2FAngular%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[初识12345678&lt;!--ng-init 初始化变量--&gt;&lt;body ng-app=&quot;&quot; ng-init=&quot;name=&apos;zhangsan&apos;&quot;&gt; &lt;!--哪里使用angular就在哪一块加上ng-app--&gt; &lt;div&gt; &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt; &lt;div&gt;hello,&#123;&#123; name &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 输出表达式 {}123456&lt;body ng-app=&quot;&quot; ng-init=&quot;num1 = 0; num2 = 0&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;num1&quot; /&gt; &lt;input type=&quot;text&quot; ng-model=&quot;num2&quot; /&gt; // &#123;&#123;输出表达式:包括变量,以及各种运算符的组合&#125;&#125; &#123;&#123;num1*num2&#125;&#125;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular 指令]]></title>
      <url>%2F2017%2F04%2F10%2FAngular%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[ng-click &amp; ng-if &amp; ng-show1234567&lt;div ng-app=&quot;&quot; ng-init=&quot;isShow=true&quot;&gt; &lt;button ng-click=&quot;isShow=!isShow&quot;&gt;点击显示/隐藏&lt;/button&gt; &lt;!--ng-if操作的节点的插入和移出--&gt; &lt;!--ng-show操作节点的display block和none--&gt; &lt;div ng-show=&quot;isShow&quot; class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div ng-hide=&quot;isShow&quot; class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt; ng-repeat1234567891011121314&lt;!--数组--&gt;&lt;div ng-app=&quot;&quot; ng-init=&quot;arr=[3,4,5]&quot;&gt; &lt;ul&gt; &lt;!--获取 下标值 和 内容--&gt; &lt;li ng-repeat=&quot;(index,item) in arr&quot;&gt;&#123;&#123;index+&quot;=&gt;&quot;+item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!--对象--&gt;&lt;div ng-app=&quot;&quot; ng-init=&quot;person=&#123;name:&apos;zhangsan&apos;,age:18&#125;&quot;&gt; &lt;ul&gt; &lt;!--获取 下标值 和 内容--&gt; &lt;li ng-repeat=&quot;(index,item) in person&quot;&gt;&#123;&#123;index+&quot;=&gt;&quot;+item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ng-class123456&lt;div ng-app=&quot;&quot; ng-init=&quot;ischange=true;&quot;&gt; &lt;!--点击改变ischange的值--&gt; &lt;button ng-click=&quot;ischange=!ischange&quot;&gt;点击改变样式&lt;/button&gt; &lt;!--根据ischange的值来给className--&gt; &lt;div class=&quot;div1&quot; ng-class=&quot;&#123;true:&apos;act&apos;,false:&apos;inact&apos;&#125;[ischange]&quot;&gt;我是样式&lt;/div&gt;&lt;/div&gt; ng-include1234&lt;body ng-app=&quot;&quot;&gt; &lt;div ng-include=&quot;&apos;header.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;footer.html&apos;&quot;&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_createServer]]></title>
      <url>%2F2017%2F03%2F16%2FNode_createServer%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021// 需要引入 node 的原生模块&quot;http&quot;var http = require(&quot;http&quot;);var server = http.createServer(function(req,res)&#123; req: require,包含一些url信息 以及传入的数据 res: response,包含请求回应的状态码 返回的信息等等 req.url // &quot;/&quot;根目录 req.method // 请求方式 console.log(req,res) console.log(req.url) res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;&#125;); // 设置编码utf8 // write 只做回应 不代表请求的结束 res.write(&quot;我是直接回应&quot;); // end 不只是输出返回的内容 还代表着本次请求的结束 res.end(&quot;我是本次请求的回应&quot;);&#125;)server.listen(8080); // 设置本服务的端口号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_fs]]></title>
      <url>%2F2017%2F03%2F16%2FNode_fs%2F</url>
      <content type="text"><![CDATA[读取文件异步写法1234567fs.readFile(&quot;test.txt&quot;,&quot;utf-8&quot;,function(err,data)&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log(data); &#125;&#125;) 同步写法1234var data = fs.readFileSync(&quot;test.txt&quot;,&quot;utf-8&quot;);console.log(data);console.log(&quot;我是读取操作之后的内容&quot;) 写入文件123456fs.writeFile(&quot;test.txt&quot;,&quot;我是写入的内容&quot;,&#123;flag:&quot;a&quot;&#125;,function(err)&#123; if(err)&#123; console.log(err) &#125; console.log(&quot;写入成功&quot;)&#125;) 目录操作123456789var fs = require(&quot;fs&quot;);fs.mkdir(&quot;test2&quot;,055,function(err)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&quot;创建成功&quot;);6 &#125;&#125;)// mode 是权限的作用 是一个三位8进制数 每一位数字由1,2,4,组成 1可执行 2可写 4可读 删除目录1234567fs.rmdir(&quot;test2&quot;,function(err)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&quot;删除成功&quot;); &#125;&#125;) 读取目录(输出指定目录下除了.和..的所有文件组成的数组)1234567fs.readdir(&quot;./&quot;,function(err,files)&#123; if(err)&#123; console.log(err); &#125;else&#123; // console.log(files) &#125;&#125;) 输出文件或目录的详情1234567fs.stat(&quot;./test.txt&quot;,function(err,stat)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(stat) &#125;&#125;) 判断文件是否存在1234fs.exists(&quot;test&quot;,function(exists)&#123; // 存在为true 反之为false console.log(exists)&#125;) 通过相对路径获得绝对路径1234567fs.realpath(&quot;test&quot;,function(err,path)&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log(path); &#125;&#125;) 重命名1234567fs.rename(&quot;test&quot;,&quot;newtest&quot;,function(err)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&quot;重命名成功&quot;); &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_buffer]]></title>
      <url>%2F2017%2F03%2F16%2FNode_buffer%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_event]]></title>
      <url>%2F2017%2F03%2F16%2FNode_event%2F</url>
      <content type="text"><![CDATA[事件：又称为发布订阅模式或者观察者模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// var events = require(&quot;events&quot;).EventEmitter; // 旧写法var events = require(&quot;events&quot;); // 引入events模块var util = require(&quot;util&quot;);// 创建事件的发布者以及事件的观察者function Girl()&#123; // 假设女神饿了&#125;function Boy(name,response)&#123; this.name = name, this.response = response&#125;var goddess = new Girl(function()&#123; console.log(&quot;自己打电话叫外卖&quot;);&#125;);var boy1 = new Boy(&quot;备胎1&quot;,function()&#123; console.log(&quot;点饿了么&quot;);&#125;)var boy2 = new Boy(&quot;备胎2&quot;,function()&#123; console.log(&quot;上美团外卖&quot;);&#125;)var boy3 = new Boy(&quot;备胎3&quot;,function()&#123; console.log(&quot;上百度外卖&quot;);&#125;)util.inherits(Girl,events);// 继承来自于events的原型方法// 设置监听者的最大数goddess.setMaxListeners(2);// 只是绑定监听者goddess.on(&quot;ele&quot;,boy1.response);goddess.on(&quot;ele&quot;,boy2.response);goddess.addListener(&quot;ele&quot;,boy3.response);goddess.on(&quot;ele&quot;,function()&#123; console.log(&quot;自己叫外卖&quot;)&#125;);// once 绑定的事件只会触发一次goddess.once(&quot;ele&quot;,function()&#123; console.log(&quot;女神饿死了&quot;);&#125;);// 移除事件goddess.removeListener(&quot;ele&quot;,boy2.response);// 移除所有事件goddess.removeAllListeners(&quot;ele&quot;);// 发送事件(事件触发)goddess.emit(&quot;ele&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_createServer]]></title>
      <url>%2F2017%2F03%2F16%2FNode_require%2F</url>
      <content type="text"><![CDATA[引入原生模块1var http = require(&quot;http&quot;); 加载自定义模块12// 引入本目录下的自定义模块要加上路径var home = require(&quot;./home.js&quot;); 非本目录下的自定义模块(按以下顺序)1234// 1.寻找本目录下node_modules目录下的home2.js// 2.寻找本目录下node_modules/home2目录下的index.js// 3.寻找本目录下node_modules/home2目录下的package.jsonvar home = require(&quot;home2&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_stream]]></title>
      <url>%2F2017%2F03%2F16%2FNode_stream%2F</url>
      <content type="text"><![CDATA[stream:流,他的出现时为了处理大数据 把一个大的文件截取成若干个大小为64k的小文件储存var fs = require(“fs”); 复制文件123456789101112131415161718192021// 创建可读流// 每一个可读流具有data事件var rs = fs.createReadStream(&quot;1.jpg&quot;);// 创建可写流var ws = fs.createWriteStream(&quot;3.jpg&quot;);var times = 0;rs.on(&quot;data&quot;,function(chunk)&#123; // 把文件分割成64K 所以每64K会触发一次事件 times++; // console.log(times) // console.log(chunk) ws.write(chunk,function()&#123; console.log(&quot;第&quot;+times+&quot;次chunk传入成功&quot;) &#125;)&#125;)rs.on(&quot;end&quot;,function()&#123; console.log(times);&#125;) 管道123var rs = fs.createReadStream(&quot;1.jpg&quot;);var ws = fs.createWriteStream(&quot;4.jpg&quot;);rs.pipe(ws);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_util]]></title>
      <url>%2F2017%2F03%2F16%2FNode_util%2F</url>
      <content type="text"><![CDATA[util 这个模块保存了利于其他模块的工具使用最多的方法有三种 1.实现对象原型继承 2.把一个对象作为字符串输出 3.数据类型的检测引入：1var util = require(&quot;util&quot;); 实现继承(util.inherits(子类,父类))123456789101112131415161718192021222324// 创建一个父类与子类并分别实例化 子类继承父类的方法function Parent(name,age)&#123; this.name = name, this.age = age, this.sayHello = function()&#123; console.log(&quot;hello&quot;); &#125;&#125;Parent.prototype.sayName = function()&#123; console.log(this.name);&#125;function Child(name,age)&#123; // 构造函数继承 Parent.apply(this,[name,age]);&#125;util.inherits(Child,Parent); // 继承原型的方法var dad = new Parent(&quot;老爸&quot;,&quot;48&quot;);var son = new Child(&quot;儿子&quot;,&quot;28&quot;);console.log(dad.name);console.log(son.name);son.sayHello();son.sayName(); 转换成字符串(util.inspect())12var str = util.inspect(son);console.log(str); 判断数据类型(util.isArray())123456console.log(typeof &#123;&#125;)console.log(typeof &#123;&#125;)console.log(typeof (new Date()));console.log(util.isArray([]));console.log(util.isBoolean(1));console.log(util.is)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_path]]></title>
      <url>%2F2017%2F03%2F16%2FNode_path%2F</url>
      <content type="text"><![CDATA[path: 里面封装了一些对文件路径的操作 normalize 规范化字符串路径1234var path = require(&quot;path&quot;);var pathstr = &quot;a/b/./c/../d/f/./e&quot;;console.log(path.normalize(pathstr)); join 拼接路径123console.log(__dirname);console.log(path.join(__dirname,&quot;a&quot;,&quot;..b&quot;,&quot;..c/e/./d&quot;,&quot;test.txt&quot;)) resolve 将参数解析为绝对路径1console.log(path.resolve(&quot;www.baidu.com&quot;,&quot;a/..&quot;,&quot;n/..&quot;,&quot;text.html&quot;));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Less]]></title>
      <url>%2F2017%2F03%2F11%2FLess%2F</url>
      <content type="text"><![CDATA[初识less编译工具koala .less -&gt; .css 输出方式normal:普通css compress:压缩过的css 注释123/*我会被编译的*/ //我不会被编译 变量12345678// @变量名：值;@test_width:300px;// 使用.body&#123; width: @test_width; height: @test_width;&#125; 混合纯class混合123456789=====less=====.box&#123; .border;&#125;.border&#123; border:solid 5px pink;&#125; 12345=====css=====.box&#123; border:solid 5px pnik;&#125; 带参数混合123456789=====less=====.border_02(@border_width)&#123; border:solid yellow @border_width;&#125;.test_hunhe&#123; .border_02(30px);&#125; 12345=====css=====.test_hunhe &#123; border: solid yellow 30px;&#125; 不带参数混合(使用默认参数)1234567891011=====less=====.border_radius(@radius:5px)&#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;.radius_test&#123; .border_radius(10px);&#125; 1234567=====css=====.radius_test&#123; -webkit-border-radius: 10px; -moz-border-radius: 10pxx; border-radius: 10px;&#125; 匹配模式123456789101112131415161718192021=====less=====.pos(r)&#123; position: relative;&#125;.pos(a)&#123; position: absolute;&#125;.pos(f)&#123; position: fixed;&#125;.pipei&#123; .pos(r);&#125;.pipei2&#123; .pos(a);&#125;.pipei3&#123; .pos(f);&#125; 1234567891011=====css=====.pipei&#123; position: relative;&#125;.pipei2&#123; position: absolute;&#125;.pipei3&#123; position: fixed;&#125; 运算123456789=====less=====@test_01:300px;.box_02&#123; width: (@test_01 - 20) * 5; color: #ccc - 10; // 颜色转化成255,255,255计算&#125; 123456=====css=====.box_02 &#123; width: 1400px; color: #c2c2c2; &#125; 嵌套1234567891011121314151617181920=====less=====.list&#123; width: 600px; height: 600px li&#123; height: 30px; height: 30px; a&#123; float: left; // &amp;代表他的上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; &#125;&#125; 123456789101112131415=====css=====.list &#123; width: 600px; height: 600px;&#125;.list li &#123; height: 30px;&#125;.list li a &#123; float: left;&#125;.list li a:hover &#123; color: red;&#125; arguments包含了所有传进来的参数123456789=====less=====.border_arg(@w:30px,@c:red,@xx:solid)&#123; border: @arguments;&#125;.test_arg&#123; .border_arg(40px);&#125; 12345=====css=====.test_arg &#123; border: 40px red solid;&#125; 避免编译12345=====less=====.test_03&#123; width: ~&apos;calc(300px-30)&apos;;&#125; 12345=====css=====.test_03 &#123; width: calc(300px-30);&#125; !important关键字1234567891011=====less=====.border_radius(@radius:5px)&#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;.test_impotant&#123; .border_radius()!important;&#125; 1234567=====css=====.test_impotant &#123; -webkit-border-radius: 5px !important; -moz-border-radius: 5px !important; border-radius: 5px !important;&#125;]]></content>
    </entry>

    
  
  
</search>
