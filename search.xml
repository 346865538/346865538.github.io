<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Welcome]]></title>
      <url>%2F8888%2F01%2F01%2FWelcome%2F</url>
      <content type="text"><![CDATA[欢迎来到我的博客，在这里我会分享一些我在前端路上的一些经验GitHub : https://github.com/346865538]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017%2F04%2F19%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[title: 排序算法date: 2017-4-19 10:30:59description: 一些常用的排序算法categories: HTMLtags: 算法 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法 冒泡排序原理: 1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。 2.第一轮的时候最后一个元素应该是最大的一个。 3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 1234567891011function sort(el)&#123; for(var i = 0; i &lt; el.length - 1; i++)&#123; for(var j = 0; j &lt; el.length - i - 1; j++)&#123; if(el[j] &gt; el[j+1])&#123; var swap = el[j]; el[j] = el[j + 1]; el[j + 1] = swap; &#125; &#125; &#125;&#125; 快速排序原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行。 123456789101112131415161718192021222324function quickSort(oldarr)&#123; // 如果传入的数组只有一个数就直接返回数组 if(oldarr.length &lt;= 1)&#123; return oldarr; &#125; // 定义基准点为数组长度的一半向下取整 var index = parseInt(oldarr.length/2); // 定义2个空数组分别存放 小于基准数的数 和 大于基准数的数 var beforeIndex = new Array(); var afterIndex = new Array(); // 遍历 for(var i = 0; i &lt; oldarr.length; i++)&#123; // 如果传入数组的i位数 &lt; 传入数组的基准数 就把他放到beforIndex这个数组 if(oldarr[i] &lt; oldarr[index])&#123; beforeIndex.push(oldarr[i]); // 如果传入数组的i位数 &gt; 传入数组的基准数 就把他放到afterIndex这个数组 &#125;else if(oldarr[i] &gt; oldarr[index])&#123; afterIndex.push(oldarr[i]); &#125; &#125; // 拼接 return quick(beforeIndex).concat(oldarr[index],quick(afterIndex));&#125; 桶排序原理：将数组分到有限数量的桶子里。再对桶进行排序 123456789101112131415161718192021222324252627282930function bucketSort(el)&#123; var oldArray = Array(); var newArray = Array(); var tong = Array(); // 排序容器 var a = el.length; // 需要排序的数组中的数的最大值 // 将桶初始化 for(var k = 0; k &lt; a; k++)&#123; tong.push(0); &#125; var date1 = new Date(); // 将旧数组中的数放到对应的桶中 for(var i = 0; i &lt; el.length; i++)&#123; oldArray.push(el[i]); tong[oldArray[i]] += 1; &#125; for(var j = 0; j &lt; tong.length; j++)&#123; // 如果桶里有东西 if(tong[j] &gt; 0)&#123; // 桶里的东西拿出来放进新数组，并且桶中数量-- for(var l = tong[j]; l &gt; 0; l--)&#123; newArray.push(j); &#125; &#125; &#125; console.log(newArray)&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git初识]]></title>
      <url>%2F2017%2F04%2F19%2FGit%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[Git 简介Git是目前最流行的版本管理系统 Git有很多优势 其中之一就是远程操作非常简便 git clone从远程主机克隆一个版本库1$ git clone 想要克隆的库的网址 本地的目录名(可选) git remote管理主机名12345$ git remote // 查看所有远程主机$ git remote -v // 查看远程主机的网址$ git remote add // 添加远程主机$ git remote rm // 删除远程主机$ git remote rename // 远程主机改名 git fetch获取最新版本12345// 取回指定远程主机的更新$ git fetch 远程主机名// 取回指定远程主机分支的更新$ git fetch 远程主机名 远程分支名 git pull取回指定远程主机分支的更新，并与本地指定的分支合并1234$ git pull 远程主机名 远程分支名 : 本地分支名// 如果远程分支是与当前分支合并，本地分支名可省略$ git pull 远程主机名 远程分支名 git push将本地分支的更新 推送到远程主机上1$ git push 远程主机名 本地分支名 : 远程分支名 github操作流程12345$ git init // 初始化github项目$ git add . // 将本地分支更新提交到缓存区$ git commit -m &quot;a&quot; // 添加本次提交更新信息$ git remote add origin 远程库地址 // 指定提交的库地址$ git push -u origin master // 提交更新到master分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative 常用组件]]></title>
      <url>%2F2017%2F04%2F14%2FReactNative%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[TouchableHighlightTouchableHighlight组件用于封装视图 使其可以正确响应触摸操作 当按下的时候 封装的视图的不透明度会降低 同时会有一个底层的颜色透过而被用户看到 使得视图变暗或变亮TouchableHighlight只支持一个子节点 如果需要包含多个子组件 可以用一个View来包装它们123456789import React, &#123; Component &#125; from &quot;react&quot;;import &#123; TouchableHighlight // 需要在头部引入TouchableHighlight组件&#125; from &apos;react-native&apos;;// underlayColor 有触摸操作时显示出来的底层的颜色&lt;TouchableHighlight underlayColor=&#123;&quot;red&quot;&#125;&gt; &lt;Text&gt;按钮&lt;/Text&gt;&lt;/TouchableHighlight&gt; TouchableOpacityTouchableHighlight组件用于封装视图 使其可以正确响应触摸操作 当按下的时候 封装的视图的不透明度会降低 这个过程并不会真正改变视图层级此组件与TouchableHighlight的区别在于并没有额外的颜色变化 更适于一般场景TouchableOpacity只支持一个子节点 如果需要包含多个子组件 可以用一个View来包装它们123456789import React, &#123; Component &#125; from &apos;react&apos;;import &#123; TouchableOpacity // 需要在头部引入TouchableOpacity组件&#125; from &apos;react-native&apos;;// underlayColor 有触摸操作时显示出来的底层的颜色&lt;TouchableOpacity&gt; &lt;Text&gt;按钮&lt;/Text&gt;&lt;/TouchableOpacity&gt; TextInputTextInput允许用户在应用中通过键盘输入文本的基本组件1234567import React, &#123; Component &#125; from &apos;react&apos;;import &#123; TextInput // 需要在头部引入TextInput组件&#125; from &apos;react-native&apos;;// returnKeyType 决定&apos;确定&apos;按钮显示的内容&lt;TextInput placeholder=&#123;&quot;请输入&quot;&#125; returnKeyType=&#123;&quot;search&quot;&#125;&gt;&lt;/TextInput&gt; Image123456789import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Image // 需要在头部引入Image组件&#125; from &apos;react-native&apos;;// source 图片路径// 本地地址：source=&#123;require(&quot;&quot;)&#125;// 网络地址：source=&#123;&#123;uri:&quot;&quot;&#125;&#125;&lt;Image source=&#123;require(&quot;./abc.jpg&quot;)&#125; /&gt; ScrollView &amp;&amp; RefreshControlScrollView是一个包装了平台的滚动视图组件 同时还集成了触摸锁定的’响应者’系统ScrollView 必须确定一个高度 RefreshControl用在ScrollView内部 为其添加下拉刷新的功能123456789101112131415161718import React, &#123; Component &#125; from &apos;react&apos;;import &#123; ScrollView // 需要在头部引入ScrollView组件&#125; from &apos;react-native&apos;;&lt;ScrollView onScrollBeginDrag=&#123;&#125; onScrollEndDrag=&#123;&#125; onMomentumScrollBegin=&#123;&#125; onMomentumScrollEnd=&#123;&#125; refreshControl=&#123; &lt;RefreshControl refreshing=&#123;false&#125; title=&#123;&quot;正在刷新&quot;&#125; onRefresh=&#123;&#125; /&gt;&#125;&gt; &lt;View style=&#123;[styles.item,styles.item1]&#125;&gt;&lt;/View&gt; &lt;View style=&#123;[styles.item,styles.item2]&#125;&gt;&lt;/View&gt; &lt;View style=&#123;[styles.item,styles.item3]&#125;&gt;&lt;/View&gt;&lt;/ScrollView&gt;onScrollBeginDrag 开始拖拽触发的方法onScrollEndDrag 结束拖拽触发的方法onMomentumScrollBegin 滚动开始触发的方法onMomentumScrollEnd 滚动结束触发的方法refresh 请求数据触发的方法 ListView用于显示一个可以垂直滚动的变化的数据列表1.创建一个ListView.DataSource数据源2.给它传递一个普通的数据数组3.再使用数据源来实例化一个ListView组件 并且定义它的renderRow回调函数 这个函数会接受数组中的每个数据作为参数 返回一个可渲染的组件（作为listview的每一行）123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from &apos;react&apos;;import &#123; ListView // 需要在头部引入ListView组件&#125; from &apos;react-native&apos;;var news = [ &apos;news1&apos;, &apos;news2&apos;, &apos;news3&apos;, &apos;news4&apos;, &apos;news5&apos;, &apos;news6&apos;, &apos;news7&apos;]var ListViewTest = React.createClass(&#123; getInitialState:function()&#123; // 实例化数据源 var ds = new ListView.DataSource(&#123; // 通过比较新数据与旧数据 确定是否更新行组件 rowHasChanged:function(oldData,newData)&#123; return oldData != newData &#125; &#125;) return &#123; // 绑定得到的数据源 dataSource: ds.cloneWithRows(news) &#125; &#125;, _renderRow:function(rowData)&#123; // 每一行要展示的数据就是调用该函数时，自动传过来的参数 return ( &lt;View&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125;, render:function()&#123; // renderRow 展示出列表中的每一行 datasource 赋予该列表需要的数据 return &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this._renderRow&#125;/&gt; &#125;&#125;) WebView网络视图 可以在这个内部引入别的网页 使用source123456import React, &#123; Component &#125; from &apos;react&apos;;import &#123; WebView // 需要在头部引入WebView组件&#125; from &apos;react-native&apos;;&lt;WebView source=&#123;&#123;url:&quot;&quot;&#125;&#125;&gt;&lt;/WebView&gt; TabBarIOS在IOS上使用的底部TabBar组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from &apos;react&apos;;import &#123; TabBarIOS // 需要在头部引入TabBarIOS组件&#125; from &apos;react-native&apos;;//引入三个TabBar的对应页面页面var a = require(&quot;./a&quot;);var b = require(&quot;./b&quot;);var c = require(&quot;./c&quot;);var TabBarTest = React.createClass(&#123; getInitialState:function () &#123; // 显示当前显示的标签 return &#123; selectTab:&quot;a&quot; &#125; &#125;, changeTab:function (name) &#123; this.setState(&#123; selectTab:name &#125;) &#125;, render:function () &#123; return ( &lt;TabBarIOS // 标签栏的背景颜色 barTintColor=&quot;black&quot; // 当前被选中的标签图标的颜色 tintColor=&#123;&quot;orange&quot;&#125; // 没有被选中的标签图标的颜色 unselectedItemTintColor=&#123;&quot;white&quot;&#125; &gt; &#123;/*下部的标签栏*/&#125; &lt;TabBarIOS.Item // 选项的文字 title=&quot;a&quot; // 选项的图标 icon=&#123;require(&quot;./a.png&quot;)&#125; // 点击的时候触发切换内容事件 onPress=&#123;this.changeTab.bind(this,&quot;a&quot;)&#125; // 确定哪个选项被选中 selected=&#123;this.state.selectTab == &quot;a&quot;&#125; &gt; &#123;/*选项的内容*/&#125; &lt;a/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;b&quot; icon=&#123;require(&quot;./b.png&quot;)&#125; onPress=&#123;this.changeTab.bind(this,&quot;b&quot;)&#125; selected=&#123;this.state.selectTab == &quot;b&quot;&#125; &gt; &lt;b/&gt; &lt;/TabBarIOS.Item&gt; &lt;TabBarIOS.Item title=&quot;c&quot; icon=&#123;require(&quot;./c.png&quot;)&#125; onPress=&#123;this.changeTab.bind(this,&quot;c&quot;)&#125; selected=&#123;this.state.selectTab == &quot;c&quot;&#125; &gt; &lt;c/&gt; &lt;/TabBarIOS.Item&gt; &lt;/TabBarIOS&gt; ) &#125;&#125;); Navigator使用Navigator可以让你在应用的不同页面间进行切换 Navigator通过路由对象来分辨不同的页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Text, View, Navigator, // 需要在头部引入TabBarIOS组件 TextInput, TouchableOpacity&#125; from &apos;react-native&apos;;// 在进行导航时 需要先构建一些页面 使用Navigator// 创建FirstPage 和 SecondPage var FirstPage = React.createClass(&#123; render()&#123; return ( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;this.changePage&#125;&gt; &lt;Text&gt;跳转到下一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;, changePage()&#123; var nextRoute =&#123; // 指定下一页显示的内容 component: SecondPage &#125; // 添加的是路由 this.props.navigator.push(nextRoute); &#125;&#125;)var SecondPage = React.createClass(&#123; render()&#123; return( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;this.changePage&#125;&gt; &lt;Text&gt;回到第一页&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;, changePage()&#123; var nextRoute =&#123; // 指定下一页显示的内容 component: FirstPage &#125; // 添加的是路由 this.props.navigator.pop(); &#125;&#125;)var NavTest = React.createClass(&#123; render()&#123; var rootRoute = &#123; // 显示第一页 component: FirstPage &#125; return ( &lt;Navigator // 1.初始路由设置 initialRoute=&#123;rootRoute&#125; // 2.设置页面切换方式 configureScene=&#123;(route)=&gt;Navigator.SceneConfigs.PushFromRight&#125; // 3.决定渲染的场景(页面) renderScene=&#123;(route,navigator)=&gt;&#123; // 4.找到我们要渲染的页面 var Component = route.component; // 5.渲染时需要把route和navigator作为属性传入 return &lt;Component route=&#123;route&#125; navigator=&#123;navigator&#125;/&gt; &#125;&#125; /&gt; ) &#125;&#125;) fetch发起网络请求12345678fetch(&quot;http://m.maoyan.com/movie/list.json?type=hot&amp;offset=0&amp;limit=10&quot;).then((res)=&gt;res.json()).then((res)=&gt; &#123; // 请求成功的回调&#125;).catch((err)=&gt; &#123; // 请求失败的回调&#125;) 封装一些开发中常用的组件状态、属性和方法1.Loading 组件的使用 2.Fetch 请求(get) 3.设备的宽和高 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Dimensions, ActivityIndicator&#125; from &apos;react-native&apos;;var Util = &#123; windowSize:&#123; width: Dimensions.get(&quot;window&quot;).width, height: Dimensions.get(&quot;window&quot;).height &#125;, getRequest(url,succCb,failCb)&#123; fetch(url).then(function(res)&#123; return res.json() &#125;).then(function(res)&#123; cussCb(res) &#125;).catch(function(err)&#123; failCb(err) &#125;) &#125;, loading: &lt;ActivityIndicator style=&#123;&#123;marginTop:100&#125;&#125; /&gt;&#125;module.exports = Util;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue 初识]]></title>
      <url>%2F2017%2F04%2F13%2FVue%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[创建一个Vue实例123456789101112131415161718&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 实例化一个Vue对象 var app = new Vue(&#123; // 指定Vue区域 el: &apos;#app&apos;, data: &#123; // 变量 &#125;, methods:&#123; // 方法 &#125; &#125;)&lt;/script&gt; #]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative 初识]]></title>
      <url>%2F2017%2F04%2F10%2FReactNative%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[创建一个ReactNative实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 引入需要使用的组件import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;// *// RN的样式分为两类 分别为StyleSheet实例化的样式 和内联样式// 多个样式混合使用时,使用拼接样式 把所有的样式放到数组中// 在拼接时,谁靠后谁得优先级高// *// 创建组件var StyleTest = React.createClass(&#123; render:function()&#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;[styles.top,styles.border]&#125;&gt;&lt;/View&gt; &lt;View style=&#123;styles.bottom&#125;&gt;&lt;/View&gt; &lt;/View&gt; ) &#125;&#125;)// 创建样式var styles = StyleSheet.create(&#123; container:&#123; width: 300, marginTop: 25, marginRight: 10, marginLeft: 40, backgroundColor: &quot;red&quot; &#125;, top: &#123; width: 280, height: 250, backgroundColor: &quot;green&quot;, padding: 5, marginLeft: 10 &#125;, bottom:&#123; width: 250, height: 230, marginLeft: 25, marginTop: 20, backgroundColor: &quot;yellow&quot; &#125;, border:&#123; borderWidth: 3, borderColor: &quot;#000&quot; &#125;&#125;)// 注册组件 项目名 组件名AppRegistry.registerComponent(&apos;HelloReact&apos;, () =&gt; StyleTest); 组件引入与传值 index.ios.js header.js // 头部子组件 note.js // 文字子组件 父组件将数据content通过属性的方式传给子组件子组件通过this.props来获取并显示到组件内123456789101112131415161718192021222324252627282930313233343536=====index.ios.js`=====import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;// 需要传给子组件的数据(模拟)var content = [ &quot;1、Text是用于显示文本的组件&quot;, &quot;2、Text之间也能进行互相的嵌套&quot;, &quot;3、Text组件的常用样式有字体颜色、背景颜色、字体大小、字体加粗等&quot;, &quot;4、Text组件能添加点击事件&quot;]// 引入头部和文字子组件var Header = require(&quot;./header&quot;);var Note = require(&quot;./Note&quot;);// 创建组件var TextTest = React.createClass(&#123; render:function()&#123; return( &lt;View&gt; &lt;Header&gt;&lt;/Header&gt; // 通过属性传值 &lt;Note content=&#123;content&#125;&gt;&lt;/Note&gt; &lt;/View&gt; ) &#125;&#125;)AppRegistry.registerComponent(&apos;HelloReact&apos;, () =&gt; TextTest); 1234567891011121314151617181920212223242526272829303132333435363738394041424344=====header.js`=====import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;var Header = React.createClass(&#123; render:function()&#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.font&#125;&gt; &lt;Text&gt;今日&lt;/Text&gt; &lt;Text style=&#123;styles.key&#125;&gt;要记&lt;/Text&gt; &lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;)var styles = StyleSheet.create(&#123; container:&#123; marginTop: 25, height: 44, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot;, borderBottomWidth: 1, borderColor: &quot;#eee&quot; &#125;, font: &#123; fontSize: 25, fontWeight: &quot;bold&quot; &#125;, key:&#123; backgroundColor: &quot;red&quot;, color: &quot;white&quot; &#125;&#125;)// 导出组件module.exports = Header; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849=====note.js`=====import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;var Note = React.createClass(&#123; handlePress:function(i)&#123; alert(&quot;点到文字了&quot;+i); &#125;, render:function()&#123; var content = this.props.content; var noteLists = []; for(var i in content)&#123; var text = &lt;Text numberOfLines=&#123;1&#125; key=&#123;i&#125; onPress=&#123;this.handlePress(i)&#125; style=&#123;styles.note&#125;&gt;&#123;content[i]&#125;&lt;/Text&gt;; noteLists.push(text); &#125; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;Text相关知识&lt;/Text&gt; &lt;View style=&#123;styles.container&#125;&gt; &#123;noteLists&#125; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125;)var styles = StyleSheet.create(&#123; container:&#123; margin: 10 &#125;, title:&#123; color: &quot;red&quot;, fontSize: 18 &#125;, note:&#123; fontSize: 14, lineHeight: 25 &#125;&#125;)// 导出组件module.exports = Note;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React 初识]]></title>
      <url>%2F2017%2F04%2F10%2FReact%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[初始化React1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;React&lt;/title&gt; &lt;!--引入react核心库--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;build/react.js&quot;&gt;&lt;/script&gt; &lt;!--引入react的dom操作--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;!--把jsx语法转换成浏览器识别的js语法--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--把通过react生成的dom放置在这里--&gt; &lt;div id=&quot;container&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;!--写jsx的地方需要设置为text/babel--&gt; &lt;script type=&quot;text/babel&quot;&gt; &lt;/script&gt;&lt;/html&gt; ReactDOM.render123456789101112131415161718192021222324252627// 把react的dom结构渲染到页面需要的命令为 ReactDom.render()// 包括三个参数// 1.需要渲染的DOM结构// 2.要插入到的节点// 3.渲染成功的回调 (一般都不写)ReactDOM.render( &lt;h1&gt;我是标题&lt;/h1&gt;, document.getElementById(&quot;container&quot;))// jsx 是一个语法 不是一门新的语言// 既包括JavaScript 和 XHTML 语言// XHTML 就用标签来进行表示// JavaScript 用&#123;&#125;表示var names = [&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;];ReactDOM.render( &lt;ul&gt; &#123; names.map(function(name,key)&#123; return &lt;li key=&#123;key&#125;&gt;&#123;name&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;, document.getElementById(&quot;container&quot;)) 组件 component123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 在react中 将一些重用的DOM结构进行封装 就称为组件(component)// 一个组件就是一个组件类// 命名规则：// 首字母必须大写 使用驼峰命名法// 构建一个组件类使用 React.createClass()// 包含一个必须的方法是 render 它可以给我们返回一个或一组能够渲染的dom结构// 在react里如果输出多个同级标签 一定要加上一个父级var HelloMessage = React.createClass(&#123; render:function()&#123; return &lt;h1&gt;hello message&lt;/h1&gt;; &#125;&#125;)ReactDOM.render( &lt;HelloMessage/&gt;, document.getElementById(&apos;container&apos;))// 复合组件 可以把多个组件相互组合 组成一个符合组件var WebName = React.createClass(&#123; render:function()&#123; return &lt;h1&gt;我是WebShow&lt;/h1&gt; &#125;&#125;)var WebLink = React.createClass(&#123; render:function()&#123; return &lt;a href=&quot;http://www.lanou3g.com&quot;&gt;蓝鸥科技&lt;/a&gt; &#125;&#125;)var WebShow = React.createClass(&#123; render:function()&#123; return &lt;div&gt; &lt;WebName/&gt; &lt;WebLink/&gt; &lt;/div&gt; &#125;&#125;)ReactDOM.render( &lt;WebShow/&gt;, document.getElementById(&quot;container&quot;))//*react的css样式可以分为三类// 1.内联样式// 2.对象样式// 3.选择器样式// 1.使用内联样式给div添加背景颜色和边框// 2.使用对象样式给h1添加字体颜色和背景颜色// 3.使用选择器样式geip添加字体颜色和背景颜色 !使用classNamevar styles = &#123; color:&quot;blue&quot;, backgroundColor:&quot;green&quot;&#125;var StyleTest = React.createClass(&#123; render:function()&#123; return (&lt;div style=&#123;&#123;backgroundColor:&quot;red&quot;,borderWidth:&quot;1px&quot;,borderColor:&quot;green&quot;,borderStyle:&quot;solid&quot;&#125;&#125;&gt; &lt;h1 style=&#123;styles&#125;&gt;我是标题&lt;/h1&gt; &lt;p className=&quot;act&quot;&gt;我是段落&lt;/p&gt; &lt;/div&gt;) &#125;&#125;)ReactDOM.render( &lt;StyleTest/&gt;, document.getElementById(&quot;container&quot;)) 组件的属性 props12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//* props 代表的是一个组件的属性 实质上是从父组件传递一些值到子组件上// 一般情况下props最好不要更改// 使用时通过this.props, this代表父组件 props是一个数组 包含了父组件上所有的属性var WebName = React.createClass(&#123; render:function()&#123; return &lt;h1&gt;&#123;this.props.webname&#125;&lt;/h1&gt; &#125;&#125;)var WebLink = React.createClass(&#123; render:function()&#123; return &lt;a href=&#123;this.props.weblink&#125;&gt;&#123;this.props.weblink&#125;&lt;/a&gt; &#125;&#125;)var WebShow = React.createClass(&#123; render:function()&#123; return (&lt;div&gt; &lt;WebName webname=&#123;this.props.wname&#125;/&gt; &lt;WebLink weblink=&#123;this.props.wlink&#125;/&gt; &lt;/div&gt;) &#125;&#125;)ReactDOM.render( &lt;WebShow wname=&quot;百度&quot; wlink=&quot;http://www.baidu.com&quot;/&gt;, document.getElementById(&quot;container&quot;))// this.props里面的值与组件上的属性一一对应 一般不会更改 但是能够设置初始值var PropsTest = React.createClass(&#123; propTypes:&#123; // 设置props的数据类型 age:React.PropTypes.number.isequired &#125;, getDefaultProps:function()&#123; // 设置该组件属性的初始值 return &#123; name:&quot;lisi&quot;, age:18 &#125; &#125;, render:function()&#123; return &lt;h1&gt;hello &#123;this.props.name&#125;! 年龄是&#123;this.props.age&#125;&lt;/h1&gt; &#125;&#125;)var age = 18;ReactDOM.render( &lt;PropsTest/&gt;,// &lt;PropsTest name=&quot;zhangsan&quot;/&gt;, document.getElementById(&quot;container&quot;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular 初识]]></title>
      <url>%2F2017%2F04%2F10%2FAngular%E5%88%9D%E8%AF%86%2F</url>
      <content type="text"><![CDATA[初始化一个AngularJS1234567891011&lt;!-- ng-app 初始化一个AngularJS(Angular的管辖范围) ng-init 初始化变量 ng-model 将值绑定到变量--&gt;&lt;body ng-app=&quot;&quot; ng-init=&quot;name=&apos;zhangsan&apos;&quot;&gt; &lt;div&gt; &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt; &lt;div&gt;hello,&#123;&#123; name &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; AngularJS 表达式123456// &#123;&#123;&#125;&#125; 输出表达式:包括变量,以及各种运算符的组合&lt;body ng-app=&quot;&quot; ng-init=&quot;num1 = 0; num2 = 0&quot;&gt; &lt;input type=&quot;text&quot; ng-model=&quot;num1&quot; /&gt; &lt;input type=&quot;text&quot; ng-model=&quot;num2&quot; /&gt; &#123;&#123;num1*num2&#125;&#125;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular 进阶]]></title>
      <url>%2F2017%2F04%2F10%2FAngular%E8%BF%9B%E9%98%B6%2F</url>
      <content type="text"><![CDATA[controller 控制器1234567891011121314151617181920212223242526// 在一个页面里只能存在一个ng-app=&quot;&quot;,多了就只执行第一个,但是在一个页面里可以划分为不同的部分,(使用不同的控制器(controller)进行划分)// 每个控制器都有一个域,这个域使用$scope表示&lt;body&gt; &lt;div ng-app=&quot;myapp&quot;&gt; &lt;div ng-controller=&quot;mycon1&quot;&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;div ng-controller=&quot;mycon2&quot;&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 获取控制区域 中括号表示引入的依赖 var app = angular.module(&quot;myapp&quot;,[]); // 设置控制器 app.controller(&quot;mycon1&quot;,function($scope)&#123; $scope.name = &quot;zhangsan&quot;; &#125;); app.controller(&quot;mycon2&quot;,function($scope)&#123; $scope.name = &quot;lisi&quot;; &#125;)&lt;/script&gt; directive 自定义属性123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div ng-app=&quot;myApp&quot;&gt; &lt;div ng-controller=&quot;myController&quot;&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;ng-hello&gt;&lt;/ng-hello&gt; &lt;div ng-hello=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;ng-hello&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module(&quot;myApp&quot;,[]); app.controller(&quot;myController&quot;,function($scope)&#123; $scope.name=&quot;div&quot;; &#125;) //创建指令(对常用的dom结构和功能进行分装) app.directive(&quot;ngHello&quot;,function()&#123; return &#123; // restrict : &quot;A&quot;,//属性类型 // restrict : &quot;E&quot;,//标签类型 // restrict : &quot;C&quot;,//class类型 restrict: &quot;M&quot;, //作为注释使用 // restrict:默认为EA restrict : &quot;AEC&quot;,//全部类型 template : &quot;&lt;h1&gt;&lt;a href=&apos;###&apos;&gt;我是一个超文本链接&lt;/a&gt;&lt;/h1&gt;&quot; &#125; &#125;)&lt;/script&gt; Service 服务$http服务1234567891011// 向服务器发送请求，接受服务器返回的数据var app = angular.module(&quot;myapp&quot;,[&quot;ngSanitize&quot;]);app.controller(&quot;mycon&quot;,function($scope,$http)&#123; $http.get(&quot;test.txt&quot;).then(function(res)&#123; // 成功的回调 console.log(res.data); &#125;,function(err)&#123; // 失败的回调 console.log(err); &#125;)&#125;) $location 服务12345// 返回当前页面的 URL 地址var app = angular.module(&quot;myapp&quot;,[&quot;ngSanitize&quot;]);app.controller(&quot;mycon&quot;,function($scope,$location)&#123; console.log($location.absUrl());&#125;) $timeout $interval 服务12345678910111213var app = angular.module(&quot;myapp&quot;,[]);app.controller(&quot;mycon&quot;,function($scope,$timeout)&#123; $timeout(function()&#123; console.log(&quot;你好&quot;); &#125;,1000)&#125;)var app = angular.module(&quot;myapp&quot;,[]);app.controller(&quot;mycon&quot;,function($scope,$interval)&#123; $interval(function()&#123; console.log(&quot;你好&quot;); &#125;,1000)&#125;) jsonp12345678var app = angular.module(&quot;myapp&quot;,[]);app.controller(&quot;mycon&quot;,function($scope,$http)&#123; $scope.change = function()&#123; $http.jsonp(&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot;+$scope.name+&quot;&amp;cb=JSON_CALLBACK&quot;).then(function(res)&#123; console.log(res.data.s); &#125;) &#125;&#125;) 存取cookie $cookies1.3版本以下存取12345var myapp = angular.module(&apos;myapp&apos;, [&apos;ngCookies&apos;]);myapp.controller(&apos;myCtrl&apos;, function($cookies, $scope) &#123; $cookies.key1 = &apos;aaaaaaaaaaaaaaa&apos;; console.log($cookies.key1);&#125;) 1.4版本以上存取12345678910var app=angular.module(&apos;myapp&apos;, [&apos;ngCookies&apos;]);app.controller(&apos;myCtrl&apos;, function($cookies) &#123; // 存 $cookies.put(&apos;myFavorite&apos;, &apos;aaaaa&apos;); // 取 var favoriteCookie = $cookies.get(&apos;myFavorite&apos;); console.log(favoriteCookie); // 删 $cookieStore.remove(&quot;nowUser&quot;);&#125;); | 过滤器currency 格式化数字为货币格式。filter 从数组项中选择一个子集。lowercase 格式化字符串为小写。orderBy 根据某个表达式排列数组。uppercase 格式化字符串为大写。123456789101112131415&lt;body&gt; &lt;div ng-app=&quot;myapp&quot; ng-controller=&quot;mycon&quot;&gt; &#123;&#123;price | currency:&quot;￥&quot;&#125;&#125; &#123;&#123;hello | uppercase&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;angular-sanitize.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = angular.module(&quot;myapp&quot;,[]); app.controller(&quot;mycon&quot;,function($scope)&#123; $scope.price = 180; $scope.hello = &quot;hello&quot;; &#125;)&lt;/script&gt; 路由AngularJS 路由允许我们通过不同的 URL 访问不同的内容 以此来实现多视图的单页Web应用通常我们的URL形式为 http://abc.com/abc/abc，但在单页Web应用中 AngularJS 通过 # + 标记 实现，例如：http://abc.com/#/ahttp://abc.com/#/bhttp://abc.com/#/c 使用步骤：1.载入angular-route.js2.注入 ngRoute 模块3.使用 ngView 指令 使用了该指令的元素内的 HTML 内容会根据路由的变化而变化4.配置 $routeProvider 用来自定义路由规则123456789101112131415161718&lt;script src=&quot;http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js&quot;&gt;&lt;/script&gt;&lt;body ng-app=&apos;myapp&apos;&gt; &lt;div&gt;&lt;a href=&quot;#/&quot;&gt;首页&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a href=&quot;#/computers&quot;&gt;电脑&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a href=&quot;#/printers&quot;&gt;打印机&lt;/a&gt;&lt;/div&gt; &lt;div&gt;&lt;a href=&quot;#/blabla&quot;&gt;其他&lt;/a&gt;&lt;/div&gt; &lt;div ng-view&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; angular.module(&apos;myapp&apos;,[&apos;ngRoute&apos;]) .config([&apos;$routeProvider&apos;, function($routeProvider)&#123; $routeProvider .when(&apos;/&apos;,&#123;template:&apos;这是首页页面&apos;&#125;) .when(&apos;/computers&apos;,&#123;template:&apos;这是电脑分类页面&apos;&#125;) .when(&apos;/printers&apos;,&#123;template:&apos;这是打印机页面&apos;&#125;) .otherwise(&#123;redirectTo:&apos;/&apos;&#125;); &#125;]);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular 指令]]></title>
      <url>%2F2017%2F04%2F10%2FAngular%E6%8C%87%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[AngularJS 指令AngularJS 通过指令来添加功能AngularJS 可以自定义指令 ng-click &amp; ng-if &amp; ng-show1234567// ng-if操作的节点的插入和移出// ng-show操作节点的 display 的 block 和 none&lt;div ng-app=&quot;&quot; ng-init=&quot;isShow=true&quot;&gt; &lt;button ng-click=&quot;isShow=!isShow&quot;&gt;点击显示/隐藏&lt;/button&gt; &lt;div ng-show=&quot;isShow&quot; class=&quot;div1&quot;&gt;&lt;/div&gt; &lt;div ng-hide=&quot;isShow&quot; class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt; ng-repeat123456789101112131415// 数组&lt;div ng-app=&quot;&quot; ng-init=&quot;arr=[1,2,3]&quot;&gt; &lt;ul&gt; &lt;!--获取 下标值 和 内容--&gt; &lt;li ng-repeat=&quot;(index,item) in arr&quot;&gt;&#123;&#123;index+&quot;=&gt;&quot;+item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// 对象&lt;div ng-app=&quot;&quot; ng-init=&quot;person=&#123;name:&apos;zhangsan&apos;,age:18&#125;&quot;&gt; &lt;ul&gt; &lt;!--获取 下标值 和 内容--&gt; &lt;li ng-repeat=&quot;(index,item) in person&quot;&gt;&#123;&#123;index+&quot;=&gt;&quot;+item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ng-class12345// 根据ischange的值来给className&lt;div ng-app=&quot;&quot; ng-init=&quot;ischange=true;&quot;&gt; &lt;button ng-click=&quot;ischange=!ischange&quot;&gt;点击改变样式&lt;/button&gt; &lt;div class=&quot;div1&quot; ng-class=&quot;&#123;true:&apos;act&apos;,false:&apos;inact&apos;&#125;[ischange]&quot;&gt;我是样式&lt;/div&gt;&lt;/div&gt; ng-include12345// 插入html文件&lt;body ng-app=&quot;&quot;&gt; &lt;div ng-include=&quot;&apos;header.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;footer.html&apos;&quot;&gt;&lt;/div&gt;&lt;/body&gt; 更多指令AnularJS-指令参考手册 : http://www.runoob.com/angularjs/angularjs-reference.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_createServer]]></title>
      <url>%2F2017%2F03%2F16%2FNode_createServer%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021// 需要引入 node 的原生模块&quot;http&quot;var http = require(&quot;http&quot;);var server = http.createServer(function(req,res)&#123; req: require,包含一些url信息 以及传入的数据 res: response,包含请求回应的状态码 返回的信息等等 req.url // &quot;/&quot;根目录 req.method // 请求方式 console.log(req,res) console.log(req.url) res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;&#125;); // 设置编码utf8 // write 只做回应 不代表请求的结束 res.write(&quot;我是直接回应&quot;); // end 不只是输出返回的内容 还代表着本次请求的结束 res.end(&quot;我是本次请求的回应&quot;);&#125;)server.listen(8080); // 设置本服务的端口号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_fs]]></title>
      <url>%2F2017%2F03%2F16%2FNode_fs%2F</url>
      <content type="text"><![CDATA[读取文件异步写法1234567fs.readFile(&quot;test.txt&quot;,&quot;utf-8&quot;,function(err,data)&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log(data); &#125;&#125;) 同步写法1234var data = fs.readFileSync(&quot;test.txt&quot;,&quot;utf-8&quot;);console.log(data);console.log(&quot;我是读取操作之后的内容&quot;) 写入文件123456fs.writeFile(&quot;test.txt&quot;,&quot;我是写入的内容&quot;,&#123;flag:&quot;a&quot;&#125;,function(err)&#123; if(err)&#123; console.log(err) &#125; console.log(&quot;写入成功&quot;)&#125;) 目录操作123456789var fs = require(&quot;fs&quot;);fs.mkdir(&quot;test2&quot;,055,function(err)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&quot;创建成功&quot;);6 &#125;&#125;)// mode 是权限的作用 是一个三位8进制数 每一位数字由1,2,4,组成 1可执行 2可写 4可读 删除目录1234567fs.rmdir(&quot;test2&quot;,function(err)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&quot;删除成功&quot;); &#125;&#125;) 读取目录(输出指定目录下除了.和..的所有文件组成的数组)1234567fs.readdir(&quot;./&quot;,function(err,files)&#123; if(err)&#123; console.log(err); &#125;else&#123; // console.log(files) &#125;&#125;) 输出文件或目录的详情1234567fs.stat(&quot;./test.txt&quot;,function(err,stat)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(stat) &#125;&#125;) 判断文件是否存在1234fs.exists(&quot;test&quot;,function(exists)&#123; // 存在为true 反之为false console.log(exists)&#125;) 通过相对路径获得绝对路径1234567fs.realpath(&quot;test&quot;,function(err,path)&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log(path); &#125;&#125;) 重命名1234567fs.rename(&quot;test&quot;,&quot;newtest&quot;,function(err)&#123; if(err)&#123; console.log(err) &#125;else&#123; console.log(&quot;重命名成功&quot;); &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_util]]></title>
      <url>%2F2017%2F03%2F16%2FNode_util%2F</url>
      <content type="text"><![CDATA[util 这个模块保存了利于其他模块的工具使用最多的方法有三种 1.实现对象原型继承 2.把一个对象作为字符串输出 3.数据类型的检测引入：1var util = require(&quot;util&quot;); 实现继承(util.inherits(子类,父类))123456789101112131415161718192021222324// 创建一个父类与子类并分别实例化 子类继承父类的方法function Parent(name,age)&#123; this.name = name, this.age = age, this.sayHello = function()&#123; console.log(&quot;hello&quot;); &#125;&#125;Parent.prototype.sayName = function()&#123; console.log(this.name);&#125;function Child(name,age)&#123; // 构造函数继承 Parent.apply(this,[name,age]);&#125;util.inherits(Child,Parent); // 继承原型的方法var dad = new Parent(&quot;老爸&quot;,&quot;48&quot;);var son = new Child(&quot;儿子&quot;,&quot;28&quot;);console.log(dad.name);console.log(son.name);son.sayHello();son.sayName(); 转换成字符串(util.inspect())12var str = util.inspect(son);console.log(str); 判断数据类型(util.isArray())123456console.log(typeof &#123;&#125;)console.log(typeof &#123;&#125;)console.log(typeof (new Date()));console.log(util.isArray([]));console.log(util.isBoolean(1));console.log(util.is)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_path]]></title>
      <url>%2F2017%2F03%2F16%2FNode_path%2F</url>
      <content type="text"><![CDATA[path: 里面封装了一些对文件路径的操作 normalize 规范化字符串路径1234var path = require(&quot;path&quot;);var pathstr = &quot;a/b/./c/../d/f/./e&quot;;console.log(path.normalize(pathstr)); join 拼接路径123console.log(__dirname);console.log(path.join(__dirname,&quot;a&quot;,&quot;..b&quot;,&quot;..c/e/./d&quot;,&quot;test.txt&quot;)) resolve 将参数解析为绝对路径1console.log(path.resolve(&quot;www.baidu.com&quot;,&quot;a/..&quot;,&quot;n/..&quot;,&quot;text.html&quot;));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_stream]]></title>
      <url>%2F2017%2F03%2F16%2FNode_stream%2F</url>
      <content type="text"><![CDATA[stream:流,他的出现时为了处理大数据 把一个大的文件截取成若干个大小为64k的小文件储存var fs = require(“fs”); 复制文件123456789101112131415161718192021// 创建可读流// 每一个可读流具有data事件var rs = fs.createReadStream(&quot;1.jpg&quot;);// 创建可写流var ws = fs.createWriteStream(&quot;3.jpg&quot;);var times = 0;rs.on(&quot;data&quot;,function(chunk)&#123; // 把文件分割成64K 所以每64K会触发一次事件 times++; // console.log(times) // console.log(chunk) ws.write(chunk,function()&#123; console.log(&quot;第&quot;+times+&quot;次chunk传入成功&quot;) &#125;)&#125;)rs.on(&quot;end&quot;,function()&#123; console.log(times);&#125;) 管道123var rs = fs.createReadStream(&quot;1.jpg&quot;);var ws = fs.createWriteStream(&quot;4.jpg&quot;);rs.pipe(ws);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_createServer]]></title>
      <url>%2F2017%2F03%2F16%2FNode_require%2F</url>
      <content type="text"><![CDATA[引入原生模块1var http = require(&quot;http&quot;); 加载自定义模块12// 引入本目录下的自定义模块要加上路径var home = require(&quot;./home.js&quot;); 非本目录下的自定义模块(按以下顺序)1234// 1.寻找本目录下node_modules目录下的home2.js// 2.寻找本目录下node_modules/home2目录下的index.js// 3.寻找本目录下node_modules/home2目录下的package.jsonvar home = require(&quot;home2&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_event]]></title>
      <url>%2F2017%2F03%2F16%2FNode_event%2F</url>
      <content type="text"><![CDATA[事件：又称为发布订阅模式或者观察者模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// var events = require(&quot;events&quot;).EventEmitter; // 旧写法var events = require(&quot;events&quot;); // 引入events模块var util = require(&quot;util&quot;);// 创建事件的发布者以及事件的观察者function Girl()&#123; // 假设女神饿了&#125;function Boy(name,response)&#123; this.name = name, this.response = response&#125;var goddess = new Girl(function()&#123; console.log(&quot;自己打电话叫外卖&quot;);&#125;);var boy1 = new Boy(&quot;备胎1&quot;,function()&#123; console.log(&quot;点饿了么&quot;);&#125;)var boy2 = new Boy(&quot;备胎2&quot;,function()&#123; console.log(&quot;上美团外卖&quot;);&#125;)var boy3 = new Boy(&quot;备胎3&quot;,function()&#123; console.log(&quot;上百度外卖&quot;);&#125;)util.inherits(Girl,events);// 继承来自于events的原型方法// 设置监听者的最大数goddess.setMaxListeners(2);// 只是绑定监听者goddess.on(&quot;ele&quot;,boy1.response);goddess.on(&quot;ele&quot;,boy2.response);goddess.addListener(&quot;ele&quot;,boy3.response);goddess.on(&quot;ele&quot;,function()&#123; console.log(&quot;自己叫外卖&quot;)&#125;);// once 绑定的事件只会触发一次goddess.once(&quot;ele&quot;,function()&#123; console.log(&quot;女神饿死了&quot;);&#125;);// 移除事件goddess.removeListener(&quot;ele&quot;,boy2.response);// 移除所有事件goddess.removeAllListeners(&quot;ele&quot;);// 发送事件(事件触发)goddess.emit(&quot;ele&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node_buffer]]></title>
      <url>%2F2017%2F03%2F16%2FNode_buffer%2F</url>
      <content type="text"><![CDATA[buffer 一种缓存的数据格式，缓存区出现原因，js本身只有二进制的传输，只有字符串的传输 为了保存和处理二进制数据buffer 的形势是一串数组 而数组中的每一项是一个以16进制展示的8位字节Buffer 是一个类，他能实例出一个全局对象buffer 的每一位取值范围0-255 12345678910111213141516171819202122232425// 直接创建 由系统自动生成var buff = new Buffer(12); // 参数为number 表示buffer的长度console.log(buff)// 填充值buff.fill(&quot;a&quot;,3,6);// 通过数组创建var buff2 = new Buffer([1,34,074,0xa6])var buff3 = new Buffer(&quot;今天天气很晴朗&quot;)console.log(buff3)var buff4 = new Buffer([0xe4,0xbb,0x8a,0xe5]);var buff5 = new Buffer([0xa4,0xa9,0xe5,0xa4,0xa9]);console.log(buff4.toString())// 把buffer 拼接起来 占用内存高console.log(Buffer.concat([buff4,buff5]).toString())var StringDecoder = require(&quot;string_decoder&quot;).StringDecoder; // 返回一个类var decoder = new StringDecoder();var str = decoder.write(buff4);var str2 = decoder.write(buff5);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ECMAScript6 入门]]></title>
      <url>%2F2017%2F03%2F11%2FECMAScript6%20%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 Babel ES6 在线转换工具 for-of 循环123for (var index of TestArray) &#123; console.log(index);&#125; 迭代器ES6 全新的迭代器概念 他允许我们在语言层面上定义一个序列123456789101112Test[Symbol.iterator] = function () &#123; var keys = Object.keys(this).sort(); var index = 0; return &#123; next: function () &#123; return &#123; value: keys[index], done: index++ &gt;= keys.length &#125;; &#125; &#125;&#125; generator 函数 (生成器)普通的JS函数被调用时，他们立刻运行，直到遇到return或抛出异常时才会停下来而现在当你调用一个生成器时，他不会立即执行，而是返回一个已暂停的生成器对象(test)生成器函数体每次执行一部分，每当执行到一个yield表达式的时候就会暂停 小栗子：123456789101112131415// 创建一个生成器// 生成器函数使用function*声明function* TestFn(name) &#123; yield &quot;Hello &quot; + name + &quot;!&quot;; yield &quot;I&apos;m Generators&quot;; yield &quot;see you later!&quot;;&#125;// 调用生成器后，将返回的已暂停的生成器对象存放到变量中var test = TestFn(&quot;vipcw&quot;);// 每次调用生成器对象的.next()方法时，将其自身解冻并一直运行到下一个yield表达式，再次暂停。console.log(test.next()) // Hello vipcw!console.log(test.next()) // I&apos;m Generatorsconsole.log(test.next()) // see you later! ` 模板字符串ES6中一种新的字面量语法 模板字符串可以使用反撇号字符 ` 代替普通字符串的引号 ‘ 或 “ 小栗子：123456function err(user, age) &#123; // $&#123;user&#125;和$&#123;age&#125;被称为模板占位符 throw new Error(`你好， $&#123;user&#125;，年龄$&#123;age&#125; `);&#125;err(&quot;vipcw&quot;,&quot;18&quot;); // Uncaught Error: 你好， vipcw，年龄18 模板字符串也可以多行书写模板字符串中所有的内容都会原样输出在生成的字符串中1234$(&apos;#div1&apos;).innerHTML = ` &lt;h1&gt;你好!&lt;/h1&gt; &lt;p&gt;Vipcw!&lt;/p&gt;` 不定参数newArr前的省略号表明它是一个不定参数 所有传递进来的参数都被放到一个数组中并赋值给变量newArr 12345678910function Test(...TestArr) &#123; console.log(TestArr) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] for (var value of TestArr) &#123; console.log(value) // a // b // c &#125;&#125;Test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) 所有函数参数中，只有最后一个才可以被标记为不定参数，他之前的所有参数都正常填充，多余的参数被赋值给不定参数。如果没有多余的参数，不定参数就是一个空数组12345678910function Test(a,...TestArr) &#123; console.log(a) // a console.log(TestArr) // [&quot;b&quot;, &quot;c&quot;] for (var value of TestArr) &#123; console.log(value) // b // c &#125;&#125;Test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) 默认参数123456// 如果调用时没有传递参数，将使用该表达式的值作为参数默认值function Test(a=&quot;xiaoming&quot;, b=&quot;xiaohong&quot;) &#123; console.log(`xiaowang,$&#123;a&#125;,$&#123;b&#125;`);&#125;Test(); // xiaowang,xiaoming,xiaohongTest(&quot;zhangsan&quot;,&quot;lisi&quot;); // xiaowang,zhangsan,lisi Destructuring 解构解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量 数组的解构// 使用相似的解构 可以将 a,b,c 3个变量分别赋值为 TestArray 的3个数值var TestArray = [1,2,3]var [a, b, c] = TestArray;console.log(a, b, c) // 1 2 3 var [a, b, c, d] = TestArray;console.log(a, b, c, d) // 1 2 3 undefined // 还可以在对应位留空来跳过数组中的某些值var [,,c] = [“a”, “b”, “c”]; console.log(c); // c // 通过不定参数的模式获取数组中’多余’的值12var [a, ...TestArr] = [1, 2, 3, 4];console.log(TestArr); // [2, 3, 4] 对象的解构123456var x = &#123; name: &quot;zhangsan&quot; &#125;;var y = &#123; name: &quot;lisi&quot; &#125;;var &#123; name: nameA &#125; = x;var &#123; name: nameB &#125; = y;console.log(nameA); // 张三console.log(nameB); // 李四 属性名与变量名一致时 还有一种简写123var &#123; a, b &#125; = &#123; a: &quot;zhangsan&quot;, b: &quot;lisi&quot; &#125;;console.log(a); // &quot;zhangsan&quot;console.log(b); // &quot;lisi&quot; Arrow Functions 箭头函数ES6 箭头函数：标识符=&gt;表达式箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域ES5 ES6 对比栗子：12345678// ES5var Test = function(num)&#123; console.log(num)&#125;// ES6var Test = (num)=&gt; console.log(num) 箭头函数还可以包含一个块语句使用块语句的箭头函数不会自动返回值，需要使用return语句将值返回。使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里123456789101112// ES5var Test = function()&#123; a(); b();&#125;// ES6var Test = ()=&gt; &#123; a(); b();&#125; SymbolsES6 之前 JS中一共有6种数据类型Undefined 未定义Null 空值Boolean 布尔类型Number 数字类型String 字符串类型Object 对象类型 ES6 中引入了全新的第七种数据类型 symbol调用Symbol()创建一个新的symbol每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等123var a = Symbol(); console.log(a); // Symbol()console.log(typeof(a)) // symbol 小栗子：123456var name = Symbol();var man = new Object();man[name] = &quot;vipcw&quot;;console.log(man[name]); // vipcw SetSet是一群值的集合，和数组不同，一个Set不会包含相同的元素123456789101112131415161718// new Set 创建一个新的Setvar a = new Set(&quot;vipcw&quot;)console.log(a) // Set &#123;&quot;v&quot;, &quot;i&quot;, &quot;p&quot;, &quot;c&quot;, &quot;w&quot;&#125;// set.size 获取集合的大小console.log(a.size) // 5// set.has(value) 判断是否含指定元素console.log(a.has(&quot;v&quot;)) // trueconsole.log(a.has(&quot;a&quot;)) // false// set.add(value) 添加元素a.add(&quot;a&quot;)console.log(a) // Set &#123;&quot;v&quot;, &quot;i&quot;, &quot;p&quot;, &quot;c&quot;, &quot;w&quot;, &quot;a&quot;&#125;// set.delete(value) 删除元素a.delete(&quot;v&quot;)console.log(a) // Set &#123;&quot;i&quot;, &quot;p&quot;, &quot;c&quot;, &quot;w&quot;, &quot;a&quot;&#125; Proxies 代理ES6 定义了一个新的全局构造函数: Proxies它需要2个参数，目标对象与句柄对象12var a = &#123;&#125;, b = &#123;&#125;;var proxy = new Proxy(a, b); proxy将代理的所有内部方法转发至目标调用proxy.props会返回a.props 新创建的代理会尽可能与目标的行为一致12proxy.name = &quot;lisi&quot;;console.log(a.name); // lisi Class 类ES6提供了更接近传统语言的写法，引入了Class这个概念，作为对象的模板通过class关键字，可以定义类1234567891011121314class People&#123; // 构造函数 constructor(name)&#123; this.name = name; &#125; // 类的方法 sayName()&#123; console.log(this.name) &#125;&#125;var Test = new People(&quot;vipcw&quot;)Test.sayName(); // vipcw Class之间可以通过extends关键字实现继承12// 定义一个Woman类 通过 extends 关键字继承了People类的所有属性和方法 等于复制了一个People类class Woman extends People &#123;&#125; 子类必须在constructor方法中调用super方法 否则新建实例时会报错子类没有自己的 this对象 而是继承父类的this对象12345class Woman extends People&#123; constructor(x,y)&#123; super(x,y); // 必须！调用父类的constructor(x,y) &#125;&#125; letES6新增了let命令，用来声明变量let声明的全局变量不是全局对象的属性let声明的变量不会有变量提升1let a = 0; let声明的变量拥有块级作用域123456789101112131415var for(var i = 0; i &lt; 3; i++)&#123; for(var i = 0; i &lt; 3; i++)&#123; console.log(i) &#125;&#125;// 0 1 2letfor(let i = 0; i &lt; 3; i++)&#123; for(let i = 0; i &lt; 3; i++)&#123; console.log(i) &#125;&#125;// 0 1 2 0 1 2 0 1 2 constconst 与 let 类似。一样是在声明的块级作用域内有效但 const 声明的变量只可以在声明时赋值，不可随意修改12const a = 1;a = 2; // Assignment to constant variable. 更多ES6知识ECMAScript6 入门深入浅出ES6]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Less]]></title>
      <url>%2F2017%2F03%2F11%2FLess%2F</url>
      <content type="text"><![CDATA[初识less编译工具koala .less -&gt; .css 输出方式normal:普通css compress:压缩过的css 注释123/*我会被编译的*/ //我不会被编译 变量12345678// @变量名：值;@test_width:300px;// 使用.body&#123; width: @test_width; height: @test_width;&#125; 混合纯class混合123456789=====less=====.box&#123; .border;&#125;.border&#123; border:solid 5px pink;&#125; 12345=====css=====.box&#123; border:solid 5px pnik;&#125; 带参数混合123456789=====less=====.border_02(@border_width)&#123; border:solid yellow @border_width;&#125;.test_hunhe&#123; .border_02(30px);&#125; 12345=====css=====.test_hunhe &#123; border: solid yellow 30px;&#125; 不带参数混合(使用默认参数)1234567891011=====less=====.border_radius(@radius:5px)&#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;.radius_test&#123; .border_radius(10px);&#125; 1234567=====css=====.radius_test&#123; -webkit-border-radius: 10px; -moz-border-radius: 10pxx; border-radius: 10px;&#125; 匹配模式123456789101112131415161718192021=====less=====.pos(r)&#123; position: relative;&#125;.pos(a)&#123; position: absolute;&#125;.pos(f)&#123; position: fixed;&#125;.pipei&#123; .pos(r);&#125;.pipei2&#123; .pos(a);&#125;.pipei3&#123; .pos(f);&#125; 1234567891011=====css=====.pipei&#123; position: relative;&#125;.pipei2&#123; position: absolute;&#125;.pipei3&#123; position: fixed;&#125; 运算123456789=====less=====@test_01:300px;.box_02&#123; width: (@test_01 - 20) * 5; color: #ccc - 10; // 颜色转化成255,255,255计算&#125; 123456=====css=====.box_02 &#123; width: 1400px; color: #c2c2c2; &#125; 嵌套1234567891011121314151617181920=====less=====.list&#123; width: 600px; height: 600px li&#123; height: 30px; height: 30px; a&#123; float: left; // &amp;代表他的上一层选择器 &amp;:hover&#123; color: red; &#125; &#125; &#125;&#125; 123456789101112131415=====css=====.list &#123; width: 600px; height: 600px;&#125;.list li &#123; height: 30px;&#125;.list li a &#123; float: left;&#125;.list li a:hover &#123; color: red;&#125; arguments包含了所有传进来的参数123456789=====less=====.border_arg(@w:30px,@c:red,@xx:solid)&#123; border: @arguments;&#125;.test_arg&#123; .border_arg(40px);&#125; 12345=====css=====.test_arg &#123; border: 40px red solid;&#125; 避免编译12345=====less=====.test_03&#123; width: ~&apos;calc(300px-30)&apos;;&#125; 12345=====css=====.test_03 &#123; width: calc(300px-30);&#125; !important关键字1234567891011=====less=====.border_radius(@radius:5px)&#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;.test_impotant&#123; .border_radius()!important;&#125; 1234567=====css=====.test_impotant &#123; -webkit-border-radius: 5px !important; -moz-border-radius: 5px !important; border-radius: 5px !important;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery 常用方法]]></title>
      <url>%2F2017%2F03%2F11%2FjQuery%2F</url>
      <content type="text"><![CDATA[jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程。 隐藏显示speed 的值为 slow normal fast 可以接受毫秒 hide(speed,callback) 隐藏匹配的元素，speed为过度时间，callback为隐藏后要做的事（回调函数） show(speed,callback) 显示匹配的元素。 toggle(speed,callback)方法来切换hide()和show()方法。如果隐藏则显示，如果显示则隐藏。 淡入淡出fadeIn(speed,callback)用于淡入已隐藏的元素。 fadeOut(speed,callback)用于淡出可见元素。 fadeTo(speed,opacity,callback)该方法作用于透明度，（opacity:0-1,0时元素完全透明，显示效果为隐藏了，其实只是透明了，1为完全不透明） fadeToggle(speed,callback) 如果以淡出则添加淡入效果，如果以淡入则添加淡出效果。 滑动slideDown(speed,callback)用于向下滑动元素（首先元素必须是隐藏状态)。 slideUp(spend,callback)用于向上滑动元素（首先元素必须是隐藏状态)。 slideToggle(spend,callback)方法可以在slideDown()与slideUp()方法之间进行切换。如果向下滑动结束了，点击时就向上。 动画animate({这里面是定义形成动画的css属性},speed,callback) 例如animate({right:&apos;350px’})移动到right为350px时停止。(需要定位) animate()-使用预定义的值:可以把属性的动画值设置为 &quot;show&quot;、&quot;hide&quot; 或 &quot;toggle”。 animate()-使用队列功能:当给匹配元素多个animate()时，从上到下运行。 停止动画stop(stopAll,goToEnd)。可选的 stopAll 参数规定是否应该清除动画队列,goToEnd 参数规定是否立即完成当前动画(默认都是false)。默认地，stop() 会清除在被选元素上指定的当前动画。 Callback函数函数在动画或者效果完成之后在运行：可以是声明的函数，也可以是匿名函数. Chaining链接Chaining 允许我们在一条语句中允许多个jQuery方法（在相同的元素上。 比如$(&quot;#p1&quot;).css(&quot;color&quot;,&quot;red&quot;).slideUp(2000).slideDown(2000);&quot;p1&quot; 元素首先会变为红色，然后向上滑动，然后向下滑动： 设置和获得属性内容text(value/回调函数)-设置或返回所选元素的文本内容， text和html 在获取元素的值的时候 都是获得的文本值 html设置值的时候 能解析标签 html(value/回调函数)-设置或返回所选元素的内容(包括HTML标记). val(value/回调函数)-设置或返回表单字段的值. 表单！！！！！！！ attr(“属性名”,值) 例子 $(&quot;#w3s&quot;).attr(&quot;href&quot;,&quot;http://www.w3school.com.cn/jquery”);将id=w3s的元素的href值这是为http://www.w3school.com.cn/jquery； 添加元素内部append()在被选定元素的结尾插入内容。 例如 $(&quot;p&quot;).append(&quot;Some appended text.”);在p元素后面添加字符串 字符串也可以放在标签中一起插入。 appendTo()添加到末尾 prepend()在被选定元素的开头插入内容。用法同上 。 prependTo()前端插入 外部after() 方法在被选元素之后插入内容。 insertAfter()添加到之后 before() 方法在被选元素之前插入内容。 insertBefore()添加到之前 删除元素remove()删除被选元素(及其子元素)。 方法也可接受一个参数，允许您对被删元素进行过滤。 例如 $(&quot;p&quot;).remove(&quot;.italic&quot;);例子删除 class=&quot;italic&quot; 的所有 &lt;p&gt; 元素： empty()从被选元素中删除子元素。 获取并设置css类add() 例如 $(“div”).add(“p”).css(“color”,”red”); 设置匹配的div p元素的颜色 addClass() - 向被选元素添加一个或多个类. removeClass() - 从被选元素删除一个或多个类 hasClass() toggleClass() - 对被选元素进行添加/删除类的切换操作 css() - css(&quot;propertyname&quot;)返回样式属性 设置css({&quot;propertyname&quot;:&quot;value&quot;,&quot;propertyname&quot;:&quot;value&quot;,...}); 尺寸width()方法设置或返回元素的宽度(不包括内边距、边框或外边距) height()方法设置或返回元素的高度(不包括内边距、边框或外边距) innerWidth()方法返回元素的宽度(包括内边距); innerHeight()方法返回元素高度(包括内边框); outerWidth(true) 方法返回元素的宽度（包括内边距、边框和外边距）。 outerHeight(true) 方法返回元素的高度（包括内边距、边框和外边距）。 offset() 返回第一个匹配元素相对于文档的位置. scrollLeft()设置或返回匹配元素相对滚动条左侧的偏移。(即滚动条离左边的距离) scrollTop()设置或返回匹配元素相对滚动条顶部的偏移(滚动条离顶部的距离) position() 返回匹配相对于父级的位置 $(&quot;.inner&quot;).position().left 会受父级的padding影响 遍历parent() 方法返回被选元素的直接父元素 parents()方法返回被选元素的所有祖先元素，一直到根元素(&lt;html&gt;) 例如$(&quot;span&quot;).parents(&quot;ul&quot;); 返回span所有的祖先并且是ul（往上找ul） parentsUntil()返回介于给定元素之间的所有祖先元素 $(&quot;span&quot;).parentsUntil(&quot;div&quot;);返回介于 &lt;span&gt; 与 &lt;div&gt; 元素之间的所有祖先元素。 filter() - 过滤 $(“div).filter(“.span”) 在所有匹配的div元素中，匹配所有的 class=span 的标签. index() - 例如 $(this).index() 返回当前元素相对于同胞元素的索引值(index位置) ， 如果没找到元素 则返回-1 后代children() 方法返回被选元素的所有直接子元素。 find()方法返回被选元素的后代元素，一路向下直到最后一个后代。$(&quot;div&quot;).find(&quot;span”);返回属于div的后代并且是span（往下找span）find(“*”)表示返回所有后代. 选择器 :eq(index) 匹配等index个元素:gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配h1 h2 之类的标题元素 :last() 获取最后一个元素 :animated 匹配所有在执行动画的元素 :focus 匹配当前获取焦点的元素 $(“x &gt; y”) 匹配X的元素中的所有Y(子级)元素。 $(“x + y”) 匹配所有跟在x后面的y元素 事件unbind() 移除匹配元素事件处理器（用于移除用bind()绑定的事件处理程序）; hover(inFn,outFn), //JQuery中的hover事件 inFn 代表移入时执行的函数 outFn代表移出时 执行的函数 访问对象get(index); 方法返回匹配的第index元素 测试操作$.contains(a,b)一个DOM节点是否包含另一个DOM节点。 b是否被a包住 $.type(obj)检测obj的数据类型 $.isArray(obj)检测是否为数组 $.isFuciton(obj)用于检测对象是否为函数 $.isEmptyObject(obj)测试对象是否是空对象（不包含任何属性）。 $.isNumeric(value)检测参数是否为数值 事件对象ev.currentTarget() 在事件冒泡阶段中的当前dom元素 ev.pageX 显示鼠标距离可视窗口的左边的位置 ev.pageY 顶部 ev.result 返回当前事件 最后触发的那个处理函数的返回值(undefined 则不返回) 文档操作$.trim() 去掉空格 (多用户input去空格)]]></content>
    </entry>

    
  
  
</search>
